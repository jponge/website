<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The GraalVM Frenzy | Julien Ponge</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="The GraalVM Frenzy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="It seems like the whole Java ecosystem is going mad these days with GraalVM. Every library and framework wants to proudly work on GraalVM, making GraalVM a new silver bullet for modern Java applications." />
<meta property="og:description" content="It seems like the whole Java ecosystem is going mad these days with GraalVM. Every library and framework wants to proudly work on GraalVM, making GraalVM a new silver bullet for modern Java applications." />
<link rel="canonical" href="https://julien.ponge.org/blog/the-graalvm-frenzy/" />
<meta property="og:url" content="https://julien.ponge.org/blog/the-graalvm-frenzy/" />
<meta property="og:site_name" content="Julien Ponge" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-06T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The GraalVM Frenzy" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-09-06T00:00:00+02:00","datePublished":"2018-09-06T00:00:00+02:00","description":"It seems like the whole Java ecosystem is going mad these days with GraalVM. Every library and framework wants to proudly work on GraalVM, making GraalVM a new silver bullet for modern Java applications.","headline":"The GraalVM Frenzy","mainEntityOfPage":{"@type":"WebPage","@id":"https://julien.ponge.org/blog/the-graalvm-frenzy/"},"url":"https://julien.ponge.org/blog/the-graalvm-frenzy/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://julien.ponge.org/feed.xml" title="Julien Ponge" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Julien Ponge</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/">Blog</a><a class="page-link" href="/publications/">Publications</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The GraalVM Frenzy</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-09-06T00:00:00+02:00" itemprop="datePublished">Sep 6, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>It seems like the whole Java ecosystem is going mad these days with <a href="https://www.graalvm.org/">GraalVM</a>. Every library and framework wants to proudly work on GraalVM, making GraalVM a new <em>silver bullet</em> for modern Java applications.</p>

<p>I expect the GraalVM crazyness to follow the typical hype cycle, and soon we will hear of disillusions and people will actually understand what GraalVM is <em>— and more importantly —</em> what GraalVM is not.</p>

<h2 id="where-does-graalvm-comes-from">Where does Graal(VM) comes from?</h2>

<p>Graal is a what happens when you give a group of academic and industry researchers ample time and budget to work on interesting problems.</p>

<p>The history of Graal dates back to the <a href="https://dl.acm.org/citation.cfm?id=2400689">research works on MaxineVM</a>, also known as a <em>meta-circular virtual machine</em>. If this sounds complicated then all you really have to understand is that MaxineVM is a Java virtual machine written in… Java (hence it is <em>meta-circular</em>).</p>

<p>Fast forward a few years and the people behind this project have made great research and great prototypes. Most software from research projects remain in some experimental state, but since Oracle has invested a lot over the last few years and the results are good, they now invest in turning the results of this project into a product called GraalVM.</p>

<p><em>(note: I have absolutely no insider information)</em></p>

<h2 id="so-what-is-graalvm">So what is Graal(VM)?</h2>

<p>Graal is a native code generator, just like LLVM. You give it some intermediate model of executable code, and then you get native code for processors. And of course it is written in Java.</p>

<p>Once you have a code generator, you can do many other things such as a compiler to native code for some language, you can do a JIT *(just-in-time) *compiler for another language, etc.</p>

<h2 id="why-do-people-manifest-so-much-interest">Why do people manifest so much interest?</h2>

<p>Cloud. Containers. You name it :-)</p>

<p>What excites people so much about GraalVM is a sub-project called <em>SubstrateVM</em> (SVM), and that compiles JVM applications to native executables. This is also called a <em>ahead-of-time</em> compiler.</p>

<p>Once you compile a JVM application into a native executable, it can run without a JVM. In fact, what you get is a self-contained executable just like you would get with Go.</p>

<p>This is interesting in a container world since the process starts <em>fast</em>, and since there is no virtual machine there is no code to generate with a JIT, and the process uses much less memory (a traditional issue for JVM in a memory-capped environment).</p>

<p>My colleague Paulo Lopes has a <a href="https://www.jetdrone.xyz/2018/08/10/Vertx-native-image-10mb.html">Vert.x application running as 38MB Docker image consuming 10MB of RAM</a>. While Vert.x has always been leaner compared to <em>mastodon</em> JVM frameworks, this is still an impressive result.</p>

<h2 id="so-why-do-you-talk-about-upcoming-disillusions">So why do you talk about upcoming disillusions?</h2>

<p>Don’t get me wrong: GraalVM is a very interesting project!</p>

<p>What is important however is to realize that while SVM is an interesting option compared to running a traditional JVM, things aren’t that simple.</p>

<h3 id="not-every-jvm-application-can-be-compiled-to-svm">Not every JVM application can be compiled to SVM.</h3>

<p>Reflection is a problem for an AOT compiler, so you need to help the compiler by telling it of all classes that may be dynamically loaded at runtime. Since reflection and dynamic loading are key ingredients in many libraries and frameworks, your mileage varies greatly depending on your stack.</p>

<p>You can check out the full list of limitations here: <a href="https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md">https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md</a></p>

<h3 id="there-is-no-jit">There is no JIT</h3>

<p>The native executables produced by SVM do not have a JIT compiler.</p>

<p>This means that while the process start fast compared to a JVM, there is no profiler and JIT compiler to aggressively generate better code at runtime.</p>

<h3 id="the-garbage-collector-is-simpler">The garbage-collector is simpler</h3>

<p>The JVM is a great place for the development of garbage-collectors that are suited at very specific workloads.</p>

<p>Just like there is no JIT compiler in a SVM-produced executable, the garbage-collector is a simpler one. Again, this may not necessarily be an issue in your particular setting, but it may be worth comparing how your application fares:</p>

<ul>
  <li>on a JVM with a fine-tuned GC, and</li>
  <li>as a standalone native executable.</li>
</ul>

<h2 id="graalvm-is-not-just-substratevm">GraalVM is not just SubstrateVM!</h2>

<p>Remember that Graal is a code generator, and SubstrateVM is only one facet.</p>

<p>There are more things in the larger GraalVM project like being a platform for interoperability between languages, fast implementations of JavaScript / R / Ruby, executing native code, Truffle for building language interpreters, etc.</p>

<h3 id="hotspot-is-getting-old">Hotspot is getting old</h3>

<p>The JVM traditionally uses the <em>Hotspot</em> JIT compiler, which is made of 2 compilers:</p>

<ul>
  <li>C1 emits simple native code, but which is still faster than executing bytecode in an interpreter, and</li>
  <li>C2 is a more aggressive compiler that generates better native code based on execution profiles, but it may frequently <em>de-optimize</em>, eating more memory as it generates code on the fly.</li>
</ul>

<p>C2 is the compiler that gives performance, but it is and older, complex code base written in C++. Very few people on this planet have the ability to maintain it.</p>

<h3 id="enter-graal">Enter Graal</h3>

<p>Written in Java, more extensible and easier to maintain, Graal works great as a C2 replacement.</p>

<p>My own experiments with using a JVM and Graal as a JIT compiler are that you can indeed achieve better performance. Others like Twitter have been publicly announcing better performance (and reduced costs) by using Graal instead of C2.</p>

<p>One issue that I have always had with running <a href="https://golo-lang.org/">Golo</a> code on the JVM is that C2 never managed to get rid of primitive boxing. This is not the case with Graal as a JIT compiler as it has a better escape analysis.</p>

<h2 id="summary">Summary</h2>

<p>So… should you use a JVM + Graal, or should you use SubstrateVM?</p>

<h3 id="substratevm">SubstrateVM</h3>

<p>Pros:</p>

<ul>
  <li>self-contained native executables</li>
  <li>fast process start</li>
  <li>smaller memory footprint</li>
  <li>smaller executable footprint</li>
</ul>

<p>Cons:</p>

<ul>
  <li>no JIT compiler, so lesser peak performance</li>
  <li>simple garbage-collector</li>
  <li>not all JVM code easily compiles, and when it does, you may still have surprises at runtime.</li>
</ul>

<p>Best use-cases:</p>

<ul>
  <li>command-line tools</li>
  <li>embedded / constrained devices <em>(note: ARM is not supported for SVM yet)</em></li>
  <li>containerized environments where raw performance is not the main concern</li>
</ul>

<h3 id="jvm--graal-jit-compiler">JVM + Graal JIT compiler</h3>

<p>Pros:</p>

<ul>
  <li>it’s still a regular JVM</li>
  <li>combine Graal with the best GC for your workload</li>
  <li>excellent peak performance.</li>
</ul>

<p>Cons:</p>

<ul>
  <li>traditional footprint of a JVM</li>
  <li>JVM startup times</li>
  <li>requires more iterations than C2 to reach peak performance, un-tiered compilation (e.g., Graal without C1) is slower until Graal kicks-in.</li>
</ul>

<p>Best use-cases:</p>

<ul>
  <li>services, networked services, micro-services,</li>
  <li>data processing applications where performance is critical</li>
  <li>alternative JVM languages.</li>
</ul>

<blockquote>
  <p>A preliminary version was published at <a href="https://medium.com/@jponge/the-graalvm-frenzy-f54257f5932c">https://medium.com/@jponge/the-graalvm-frenzy-f54257f5932c</a>.</p>
</blockquote>

  </div><a class="u-url" href="/blog/the-graalvm-frenzy/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Julien Ponge</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Julien Ponge</li><li><a class="u-email" href="mailto:julien@ponge.org">julien@ponge.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jponge"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jponge</span></a></li><li><a href="https://www.linkedin.com/in/JulienPonge"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">JulienPonge</span></a></li><li><a href="https://floss.social/@jponge"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#mastodon"></use></svg> <span class="username">jponge</span></a></li><li><a href="https://www.twitter.com/jponge"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jponge</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>rss</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
